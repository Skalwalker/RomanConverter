        -:    0:Source:romanToArabic.cpp
        -:    0:Graph:obj/romanToArabic.gcno
        -:    0:Data:obj/romanToArabic.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "romanToArabic.hpp"
        -:    2:
       99:    3:int letterValue(char l){
       99:    4:    switch (l) {
        -:    5:        case 'I':
       21:    6:            return 1;
        -:    7:        case 'V':
       11:    8:            return 5;
        -:    9:        case 'X':
       13:   10:            return 10;
        -:   11:        case 'L':
        8:   12:            return 50;
        -:   13:        case 'C':
       11:   14:            return 100;
        -:   15:        case 'D':
        5:   16:            return 500;
        -:   17:        case 'M':
       23:   18:            return 1000;
        -:   19:        default:
        7:   20:            return -1;
        -:   21:    }
        -:   22:}
        -:   23:
       57:   24:int validation(char roman[], int i){
        -:   25:    /*
        -:   26:        Impossivel somar mais de 3 I, X, C e M
        -:   27:    */
       57:   28:    int isFalse = 0;
       57:   29:    int isTrue = 1;
        -:   30:
        -:   31:    char atual, atual_offset1, atual_offset2, atual_offset3;
        -:   32:
       57:   33:    atual = roman[i];
       57:   34:    atual_offset1 = roman[i+1];
       57:   35:    atual_offset2 = roman[i+2];
       57:   36:    atual_offset3 = roman[i+3];
        -:   37:
       57:   38:    if(letterValue(atual) == -1){
        7:   39:        return isFalse;
        -:   40:    }
        -:   41:
       50:   42:    if((atual == 'I') && (atual_offset1 == 'I') && (atual_offset2 == 'I') && atual_offset3 == 'I'){
        1:   43:        return isFalse;
       49:   44:    } else if((atual == 'X') && (atual_offset1 == 'X') && (atual_offset2 == 'X') && atual_offset3 == 'X'){
        1:   45:        return isFalse;
       48:   46:    } else if((atual == 'C') && (atual_offset1 == 'C') && (atual_offset2 == 'C') && atual_offset3 == 'C'){
        1:   47:        return isFalse;
       47:   48:    } else if((atual == 'M') && (atual_offset1 == 'M') && (atual_offset2 == 'M') && atual_offset3 == 'M'){
        1:   49:        return isFalse;
       46:   50:    } else if((atual == 'D') && (atual_offset1 == 'D')){
        1:   51:        return isFalse;
       45:   52:    } else if((atual == 'V') && (atual_offset1 == 'V')){
        1:   53:        return isFalse;
       44:   54:    } else if((atual == 'L') && (atual_offset1 == 'L')){
        2:   55:        return isFalse;
        -:   56:    }
       42:   57:    return isTrue;
        -:   58:}
        -:   59:
       28:   60:int romanToArabic(char roman[]){
       28:   61:    int tamanho, i, arabic = 0;
        -:   62:    char atual;
        -:   63:
       28:   64:    tamanho = strlen(roman);
       70:   65:    for(i=0;i<tamanho;i++){
        -:   66:
       57:   67:        if(!validation(roman, i)){
       15:   68:            return -1;
        -:   69:        } else {
       42:   70:            atual = roman[i];
       42:   71:            printf("Atual: %c\n", atual);
       42:   72:            arabic += letterValue(atual);
        -:   73:        }
        -:   74:
        -:   75:
        -:   76:    }
        -:   77:
       13:   78:    printf("Arabic: %d\n", arabic);
        -:   79:
       13:   80:    return arabic;
        -:   81:}
